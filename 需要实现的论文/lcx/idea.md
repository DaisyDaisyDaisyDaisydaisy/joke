### 一种使用优先队列的dijkstra在cuda上的可能的方式

```
queue[]: 建立在共享内存/全局内存 维护为一个优先队列
u: 作为当前可用的最近的点 每次直接从优先队列中取出（判重）即可
thread: 仍然表示一个点
每次的松弛直接以并发的形式对所有点进行更新（本质上只有u的相邻结点能被更新，不相邻的肯定无法更新

在于减少了从当前最近点扫描相邻点的时间。

```



### 一种可能的利用闲置线程记录路径的方式

```
在普通的dijkstra并行过程中，若当前线程代表的结点已经松弛过相邻结点，则其将不会进行后续的代码，此线程即会闲置。
考虑到，最短路径的记录也是有必要的。所有可以在其是闲置的时候进行前驱的记录，这个时间和其他线程(指正在去更新别人的点)是同步的，故不会又额外的时间消耗。

可以for扫描一下相邻结点，找到自己的前驱（使用dist和边权进行判断）。这个for并不会增加额外的复杂度。因为执行if条件会有一个for，我们在else条件中添加一个for，某个线程只可能执行其中一个for，故不会添加额外的复杂度。
```

